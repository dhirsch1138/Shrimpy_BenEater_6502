#Adapted from dbuchwald @ https://github.com/dbuchwald/cc65-tools/blob/main/tutorial/03_blink/firmware.cfg
# More segments have been added
# Using the Garth's 1 chip glue logic http://wilsonminesco.com/6502primer/addr_decoding.html
#
#  62256	SRAM:  $0000-3FFF  (binary 00xxxxxxxxxxxxxx)  (There are no 16Kx8 SRAMs, so here we use half of a 32Kx8.)
#  6522	VIA1:  $600x       (binary 011000000000xxxx)
#  6522	VIA2:  $500x       (binary 010100000000xxxx)
#  6522	VIA3:  $480x       (binary 010010000000xxxx)
#  6551	ACIA1: $440x       (binary 010001000000xxxx)
#  6551	ACIA2: $420x       (binary 010000100000xxxx)
#  6551  ACIA3: $410x       (binary 010000010000xxxx)
#  27256 ROM:   $8000-FFFF  (binary 1xxxxxxxxxxxxxxx)
MEMORY
{
  #RAM is $0000-$0FFF, split up into page zero, page one (stack), and everything else
  PAGEZERO:  start=$0000, size=$0100, type=rw, define=yes, file="";
  STACK:     start=$0100, size=$0100, type=rw, define=yes, file="";
  GEN_RAM:   start=$0200, size=$3E00, type=rw, define=yes, file="";
  VIA1:       start=$6000, size=$0010, type=rw, define=yes, file="";
  ACIA1:      start=$4400, size=$0004, type=rw, define=yes, file="";
  #Apparently the eeprom don't get as much wear from 1's?
  ROM:       start=$8000, size=$8000, type=ro, define=yes, fill=yes, fillval=$FF, file=%O;
}

SEGMENTS
{
  CODE:         load=ROM, type=ro, offset=$00, define=yes;
  VIA_CODE:  load=ROM, type=ro, define=yes;
  LCD_CODE:     load=ROM, type=ro, define=yes;
  SPI_CODE:     load=ROM, type=ro, define=yes;
  WOZ_CODE:     load=ROM, type=ro, define=yes;
  VECTORS:      load=ROM, type=ro, offset=$7ffa, optional=yes, define=yes;
  #open space for ram
  LCD_RAM:      load=GEN_RAM, type=rw, define=yes;
  LCD_PAGEZERO: load=PAGEZERO, type=rw, define=yes;
  MAIN_RAM:     load=GEN_RAM, type=rw, define=yes;
  SPI_RAM:      load=GEN_RAM, type=rw, define=yes;
  WOZ_RAM:      load=GEN_RAM, type=rw, define=yes;
  WOZ_PAGEZERO: load=PAGEZERO, type=rw, define=yes;
}