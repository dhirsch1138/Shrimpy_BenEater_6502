ca65 V2.18 - Debian 2.19-1
Main file   : source/main.s
Current file: source/main.s

000000r 1               ;PURPOSE -  main code file
000000r 1               ;
000000r 1               ; adaptation from Ben Eater's keyboard.s https://eater.net/downloads/keyboard.s
000000r 1               ; mostly I am using it to learn to talk to the lcd in 4-bit mode
000000r 1               ;
000000r 1               
000000r 1               ;====================================================
000000r 1               ;Exports
000000r 1               ;nothing here
000000r 1               
000000r 1               ;====================================================
000000r 1               ;Reserve RAM addresses
000000r 1               .segment "MAIN_RAM"
000000r 1  00           MAIN_LOOP_COUNT:        .res 1, $00
000001r 1               ;Description: (HEX) Used to store count of main loop iterations
000001r 1               
000001r 1               ;====================================================
000001r 1               ;Macros
000001r 1               
000001r 1               ;====================================================
000001r 1               ;Code
000001r 1               
000001r 1                 .code
000000r 1               
000000r 1               ;Includes
000000r 1               
000000r 1                 .include "via.inc"
000000r 2               ;PURPOSE - Imports needed symbols defined in via.s
000000r 2               ;
000000r 2               
000000r 2                 .import VIA_DDRB
000000r 2                 .import VIA_PORTB
000000r 2                 .import VIA_DDRA
000000r 2                 .import VIA_PORTA
000000r 2                 .import VIA_T1CL
000000r 2                 .import VIA_T1CH
000000r 2                 .import VIA_T1LL
000000r 2                 .import VIA_T1LH
000000r 2                 .import VIA_T2CL
000000r 2                 .import VIA_T2CH
000000r 2                 .import VIA_SR
000000r 2                 .import VIA_ACR
000000r 2                 .import VIA_PCR
000000r 2                 .import VIA_IFR
000000r 2                 .import VIA_IER
000000r 2                 .import VIA_PANH
000000r 2               
000000r 1                 .include "lcd.inc"
000000r 2               ;PURPOSE - Imports needed symbols defined in lcd.s
000000r 2               ;
000000r 2               
000000r 2               .include "util_macros.inc"
000000r 3               ;Purpose: defines utility macros
000000r 3               ;As this could be included anywhere, wrap all macros in .definedmacro
000000r 3               ;.if    .definedmacro(<macroname>)
000000r 3               ;.else
000000r 3               ;.macro  <macroname> <macroargs>
000000r 3               ;  <macro stuff>
000000r 3               ;.endmacro
000000r 3               ;.endif
000000r 3               
000000r 3               
000000r 3               .if    .definedmacro(load_addr_to_zp_macro)
000000r 3               .else
000000r 3               .macro  load_addr_to_zp_macro source_addr, zp_addr
000000r 3               ;Description
000000r 3               ;  loads the address into the specified zp
000000r 3               ;Arguments
000000r 3               ;  addr - static addr (like a symbol)
000000r 3               ;  zp - zero page address
000000r 3               ;Preconditions
000000r 3               ;  none
000000r 3               ;Side Effects
000000r 3               ;  addr -> zp
000000r 3               ;Note
000000r 3               ;  The macro is overengineering, but I am using this to play with macros. "I'm learnding!"
000000r 3                 pha
000000r 3                 lda #<source_addr ; The low byte of the 16 bit address pointer is loaded into A
000000r 3                 sta zp_addr
000000r 3                 lda #>source_addr ; the high byte of the pointer
000000r 3                 sta zp_addr+1
000000r 3                 pla
000000r 3               .endmacro
000000r 3               .endif
000000r 3               
000000r 3               .if    .definedmacro(delay_macro)
000000r 3               .else
000000r 3               .macro delay_macro acount, ycount
000000r 3               ;Description
000000r 3               ;  delays for a calculable amount of cycles
000000r 3               ;Arguments
000000r 3               ;  None
000000r 3               ;Preconditions
000000r 3               ;  non
000000r 3               ;Side Effects
000000r 3               ;  nop
000000r 3               ;Note
000000r 3               ;  formula
000000r 3               ;    The delay is 9*(256*A+Y)+8 cycles
000000r 3               ;
000000r 3               ;    For example, to get approx 500k cyles
000000r 3               ;          acount - #$d9
000000r 3               ;          ycount - #$01
000000r 3               ;     9*($100*$d9+$01)+8 = $7A111 = 499985
000000r 3               ;     499985 + JSR(6) + RTS(6) = 499997
000000r 3               ;TODO: pha phy pla ply
000000r 3                 .local delay
000000r 3                 pha
000000r 3                 phy
000000r 3                 lda acount
000000r 3                 ldy ycount
000000r 3               delay:
000000r 3                 cpy #1
000000r 3                 dey
000000r 3                 sbc #0
000000r 3                 bcs delay
000000r 3                 ply
000000r 3                 pla
000000r 3               .endmacro
000000r 3               .endif
000000r 3               
000000r 3               
000000r 3               
000000r 3               
000000r 2               
000000r 2               .import lcd_instruction
000000r 2               .import lcd_init
000000r 2               .import lcd_print_asciiz_ZP
000000r 2               .import lcd_print_char
000000r 2               .import lcd_print_hex
000000r 2               
000000r 2               .importzp  LCD_PRINT_PTR
000000r 2               
000000r 2               ;Macros
000000r 2               
000000r 1                 .include "util_macros.inc"
000000r 2               ;Purpose: defines utility macros
000000r 2               ;As this could be included anywhere, wrap all macros in .definedmacro
000000r 2               ;.if    .definedmacro(<macroname>)
000000r 2               ;.else
000000r 2               ;.macro  <macroname> <macroargs>
000000r 2               ;  <macro stuff>
000000r 2               ;.endmacro
000000r 2               ;.endif
000000r 2               
000000r 2               
000000r 2               .if    .definedmacro(load_addr_to_zp_macro)
000000r 2               .else
000000r 2               .macro  load_addr_to_zp_macro source_addr, zp_addr
000000r 2               ;Description
000000r 2               ;  loads the address into the specified zp
000000r 2               ;Arguments
000000r 2               ;  addr - static addr (like a symbol)
000000r 2               ;  zp - zero page address
000000r 2               ;Preconditions
000000r 2               ;  none
000000r 2               ;Side Effects
000000r 2               ;  addr -> zp
000000r 2               ;Note
000000r 2               ;  The macro is overengineering, but I am using this to play with macros. "I'm learnding!"
000000r 2                 pha
000000r 2                 lda #<source_addr ; The low byte of the 16 bit address pointer is loaded into A
000000r 2                 sta zp_addr
000000r 2                 lda #>source_addr ; the high byte of the pointer
000000r 2                 sta zp_addr+1
000000r 2                 pla
000000r 2               .endmacro
000000r 2               .endif
000000r 2               
000000r 2               .if    .definedmacro(delay_macro)
000000r 2               .else
000000r 2               .macro delay_macro acount, ycount
000000r 2               ;Description
000000r 2               ;  delays for a calculable amount of cycles
000000r 2               ;Arguments
000000r 2               ;  None
000000r 2               ;Preconditions
000000r 2               ;  non
000000r 2               ;Side Effects
000000r 2               ;  nop
000000r 2               ;Note
000000r 2               ;  formula
000000r 2               ;    The delay is 9*(256*A+Y)+8 cycles
000000r 2               ;
000000r 2               ;    For example, to get approx 500k cyles
000000r 2               ;          acount - #$d9
000000r 2               ;          ycount - #$01
000000r 2               ;     9*($100*$d9+$01)+8 = $7A111 = 499985
000000r 2               ;     499985 + JSR(6) + RTS(6) = 499997
000000r 2               ;TODO: pha phy pla ply
000000r 2                 .local delay
000000r 2                 pha
000000r 2                 phy
000000r 2                 lda acount
000000r 2                 ldy ycount
000000r 2               delay:
000000r 2                 cpy #1
000000r 2                 dey
000000r 2                 sbc #0
000000r 2                 bcs delay
000000r 2                 ply
000000r 2                 pla
000000r 2               .endmacro
000000r 2               .endif
000000r 2               
000000r 2               
000000r 2               
000000r 2               
000000r 1               
000000r 1               reset:
000000r 1               ;Description
000000r 1               ;  The reset entrypoint for this project
000000r 1               ;Arguments
000000r 1               ;  None (called from reset)
000000r 1               ;Preconditions
000000r 1               ;  Invoked from reset vector
000000r 1               ;Side Effects
000000r 1               ;  * VIA pot B is set to output on all bits
000000r 1               ;  * intializes LCD
000000r 1               ;    * for 4bit
000000r 1               ;    * 2 line display
000000r 1               ;    * 5x8 fonts
000000r 1               ;  * enables LCD
000000r 1               ;    * Dislay on
000000r 1               ;    * cursor on
000000r 1               ;    * blink off
000000r 1               ;  * sets LCD parameters
000000r 1               ;    * increment cursor on update
000000r 1               ;    * shift cursor on update
000000r 1               ;    * do NOT shift display on update
000000r 1  A2 FF          ldx #$ff
000002r 1  9A             txs
000003r 1  A9 FF          lda #%11111111 ; Set all pins on port B to output
000005r 1  8D rr rr       sta VIA_DDRB
000008r 1  20 rr rr       jsr lcd_init
00000Br 1  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00000Dr 1  20 rr rr       jsr lcd_instruction
000010r 1  A9 0E          lda #%00001110 ; Display on; cursor on; blink off
000012r 1  20 rr rr       jsr lcd_instruction
000015r 1  A9 06          lda #%00000110 ; Increment and shift cursor; don't shift display
000017r 1  20 rr rr       jsr lcd_instruction
00001Ar 1  A9 01          lda #%00000001 ; Clear display
00001Cr 1  20 rr rr       jsr lcd_instruction
00001Fr 1  9C rr rr       stz MAIN_LOOP_COUNT
000022r 1                 ; presumes we will continue executing into 'loop'
000022r 1               
000022r 1               loop:
000022r 1               ;Description
000022r 1               ;  Loops forever updating lcd
000022r 1               ;Arguments
000022r 1               ;  None
000022r 1               ;Preconditions
000022r 1               ;  lcd is intialized and setup for display
000022r 1               ;Side Effects
000022r 1               ;  Updates LCD with the possible asciiz
000022r 1  AD rr rr       lda MAIN_LOOP_COUNT
000025r 1  20 rr rr       jsr lcd_print_hex
000028r 1  A9 20          lda #$20 ;space
00002Ar 1  20 rr rr       jsr lcd_print_char
00002Dr 1  48 A9 rr 85    load_addr_to_zp_macro alphabet, LCD_PRINT_PTR ;load the address of addr to LCD_PRINT_PTR ZP word
000031r 1  rr A9 rr 85  
000035r 1  rr 68        
000037r 1  20 rr rr       jsr lcd_print_asciiz_ZP ;print the LCD_PRINT_PTR ZP word on the LCD
00003Ar 1  A9 20          lda #$20 ;space
00003Cr 1  20 rr rr       jsr lcd_print_char
00003Fr 1  48 A9 rr 85    load_addr_to_zp_macro numbers, LCD_PRINT_PTR ;load the address of addr to LCD_PRINT_PTR ZP word
000043r 1  rr A9 rr 85  
000047r 1  rr 68        
000049r 1  20 rr rr       jsr lcd_print_asciiz_ZP ;print the LCD_PRINT_PTR ZP word on the LCD
00004Cr 1  20 rr rr       jsr half_second
00004Fr 1  20 rr rr       jsr half_second
000052r 1  A9 01          lda #%00000001 ; Clear display
000054r 1  20 rr rr       jsr lcd_instruction
000057r 1  EE rr rr       inc MAIN_LOOP_COUNT
00005Ar 1  80 C6          bra loop ;jmp
00005Cr 1               
00005Cr 1  41 42 43 44  alphabet: .asciiz "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
000060r 1  45 46 47 48  
000064r 1  49 4A 4B 4C  
000077r 1  30 31 32 33  numbers: .asciiz "0123456789"
00007Br 1  34 35 36 37  
00007Fr 1  38 39 00     
000082r 1               
000082r 1               half_second:
000082r 1               ;Description
000082r 1               ;  delays for approx 500k cycles (half second @ 1mhz)
000082r 1               ;Arguments
000082r 1               ;  None
000082r 1               ;Preconditions
000082r 1               ;  non
000082r 1               ;Side Effects
000082r 1               ;  nop
000082r 1               ;Note
000082r 1               ;  formula
000082r 1               ;    The delay is 9*(256*A+Y)+8 cycles
000082r 1               ;     9*($100*$d9+$01)+8 = $7A111 = 499985
000082r 1               ;     499985 + JSR(6) + RTS(6) = 499997
000082r 1  48 5A A9 D9    delay_macro #$d9, #$01
000086r 1  A0 01 C0 01  
00008Ar 1  88 E9 00 B0  
000091r 1  60             rts
000091r 1               
