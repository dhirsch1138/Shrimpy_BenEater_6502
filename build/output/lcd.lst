ca65 V2.18 - Debian 2.19-1
Main file   : source/lcd.s
Current file: source/lcd.s

000000r 1               ;PURPOSE - defines the static register references & lcd functions
000000r 1               ;  interface as provided by Ben Eater's videos https://eater.net/6502
000000r 1               ; adaptation from Ben Eater's keyboard.s https://eater.net/downloads/keyboard.s
000000r 1               ;  much of the code is just copied from his work, but there are many changes from me.
000000r 1               ;  rather than try to keep a diff in comments, I would encourage the reader to just diff
000000r 1               ;  this code against the linked code above.
000000r 1               ;
000000r 1               ;NOTE/TODO-
000000r 1               ;  While the LCD doesn't use all of PORTB of the VIA, this code will clobber
000000r 1               ;  DDRB for the non-LCD ports right now (basically presuming they are output)
000000r 1               ;  ideally we should try to preserve the non-LCD DDRB bits.
000000r 1               ;
000000r 1               
000000r 1               ;====================================================
000000r 1               ;Exports
000000r 1               
000000r 1               ;subroutines
000000r 1               .export lcd_instruction
000000r 1               .export lcd_init
000000r 1               .export lcd_print_asciiz_ZP
000000r 1               .export lcd_print_char
000000r 1               .export lcd_print_hex
000000r 1               ;variables
000000r 1               .export LCD_PRINT_PTR
000000r 1               
000000r 1               ;====================================================
000000r 1               ;Reserve RAM addresses
000000r 1               
000000r 1               .segment "LCD_RAM"
000000r 1  00           LCD_RS_ENABLE:        .res 1, $00
000001r 1               ;Description: (Boolean) Used to store if RS should be applied to the LCD instruction
000001r 1               ;Values:
000001r 1               ; * False - $00 for non-RS instructions (default)
000001r 1               ; * True - $FF for RS instructions (like printing characters)
000001r 1               ;Note: should be flagged with DEC as needed, always remember that its default state should be $00.
000001r 1               
000001r 1               .segment "LCD_PAGEZERO": zeropage
000000r 1  00 00        LCD_PRINT_PTR:        .res 2, $0000
000002r 1               
000002r 1               
000002r 1               
000002r 1               
000002r 1               ;====================================================
000002r 1               ;Macros
000002r 1               
000002r 1               .macro  lcd_wait_macro
000002r 1               ;Description
000002r 1               ;  Loops until the LCD no longer shows a busy status
000002r 1               ;Arguments
000002r 1               ;  None
000002r 1               ;Preconditions
000002r 1               ;  LCD is initialized and has its parameters set
000002r 1               ;  LCD is in 4 bit mode
000002r 1               ;Side Effects
000002r 1               ;  None
000002r 1                 .local lcd_wait_busy ;limit scope of this symbol to this macro
000002r 1                 pha
000002r 1                 lda #%11110000  ; LCD data is input
000002r 1                 sta VIA_DDRB
000002r 1               lcd_wait_busy:
000002r 1                 lda #LCD_4BIT_RW
000002r 1                 sta VIA_PORTB
000002r 1                 lda #(LCD_4BIT_RW | LCD_4BIT_E)
000002r 1                 sta VIA_PORTB
000002r 1                 lda VIA_PORTB       ; Read high nibble
000002r 1                 pha             ; and put on stack since it has the busy flag
000002r 1                 lda #LCD_4BIT_RW
000002r 1                 sta VIA_PORTB
000002r 1                 lda #(LCD_4BIT_RW | LCD_4BIT_E)
000002r 1                 sta VIA_PORTB
000002r 1                 ;TODO is this lda doing anything? seems like it is superceded immediately by the pla.
000002r 1                 ;unless reading from the via port triggers something on the lcd?
000002r 1                 lda VIA_PORTB       ; Read low nibble
000002r 1                 pla             ; Get high nibble off stack
000002r 1                 and #%00001000
000002r 1                 bne lcd_wait_busy
000002r 1                 ; logical break, we aren't busy anymore
000002r 1                 lda #LCD_4BIT_RW
000002r 1                 sta VIA_PORTB
000002r 1                 lda #%11111111  ; LCD data is output
000002r 1                 sta VIA_DDRB
000002r 1                 pla
000002r 1               .endmacro
000002r 1               
000002r 1               ;====================================================
000002r 1               ;Code
000002r 1               .segment "LCD_CODE"
000000r 1               
000000r 1               ;Includes
000000r 1               
000000r 1               .include "via.inc"
000000r 2               ;PURPOSE - Imports needed symbols defined in via.s
000000r 2               ;
000000r 2               
000000r 2                 .import VIA_DDRB
000000r 2                 .import VIA_PORTB
000000r 2                 .import VIA_DDRA
000000r 2                 .import VIA_PORTA
000000r 2                 .import VIA_T1CL
000000r 2                 .import VIA_T1CH
000000r 2                 .import VIA_T1LL
000000r 2                 .import VIA_T1LH
000000r 2                 .import VIA_T2CL
000000r 2                 .import VIA_T2CH
000000r 2                 .import VIA_SR
000000r 2                 .import VIA_ACR
000000r 2                 .import VIA_PCR
000000r 2                 .import VIA_IFR
000000r 2                 .import VIA_IER
000000r 2                 .import VIA_PANH
000000r 2               
000000r 1               
000000r 1               LCD_4BIT_E  = %01000000
000000r 1               LCD_4BIT_RW = %00100000
000000r 1               LCD_4BIT_RS = %00010000
000000r 1               
000000r 1               lcd_init:
000000r 1               ;Description
000000r 1               ;  Inializes the lcd, sets 4 bit mode
000000r 1               ;Arguments
000000r 1               ;  None
000000r 1               ;Preconditions
000000r 1               ;  VIA DDRB must have the LCD's bits set to output
000000r 1               ;Side Effects
000000r 1               ;  LCD is set to accept 4-bit mode
000000r 1               ;  Register A is squished
000000r 1               ;Notes
000000r 1               ;  Does not include a wait for the LCD to be ready for the next command,
000000r 1               ;  presuming that the code invoking the command will be smart enough to wait
000000r 1               ;Todo
000000r 1               ;  Should I be pushing A onto the stack such that this is transparent?
000000r 1  A9 02          lda #%00000010 ; Set 4-bit mode
000002r 1  8D rr rr       sta VIA_PORTB
000005r 1  09 40          ora #LCD_4BIT_E
000007r 1  8D rr rr       sta VIA_PORTB
00000Ar 1  29 0F          and #%00001111
00000Cr 1  8D rr rr       sta VIA_PORTB
00000Fr 1  9C rr rr       stz LCD_RS_ENABLE  ;LCD_RS_ENABLE should be false
000012r 1  60             rts
000013r 1               
000013r 1               lcd_instruction:
000013r 1               ;Description
000013r 1               ;  Sends instruction byte to the LCD
000013r 1               ;Arguments
000013r 1               ;  A - LCD instruction byte
000013r 1               ;Preconditions
000013r 1               ;  LCD is initialized and has its parameters set
000013r 1               ;  LCD is in 4 bit mode
000013r 1               ;Side Effects
000013r 1               ;  Instruction byte is sent to the LCD in 4-bit mode
000013r 1               ;  Register A is squished
000013r 1  48 A9 F0 8D    lcd_wait_macro ;wait until lcd is no longer showing BUSY
000017r 1  rr rr A9 20  
00001Br 1  8D rr rr A9  
000044r 1  48             pha
000045r 1  4A             lsr
000046r 1  4A             lsr
000047r 1  4A             lsr
000048r 1  4A             lsr            ; Send high 4 bits
000049r 1  2C rr rr       bit LCD_RS_ENABLE ; enabled RS = $FF
00004Cr 1  10 02          bpl lcd_instruction_sendhigh ; IF RS is NOT enabled THEN skip applying the RS mask
00004Er 1  09 10          ora #LCD_4BIT_RS
000050r 1               lcd_instruction_sendhigh:
000050r 1  8D rr rr       sta VIA_PORTB
000053r 1  09 40          ora #LCD_4BIT_E        ; Set E bit to send instruction
000055r 1  8D rr rr       sta VIA_PORTB
000058r 1  49 40          eor #LCD_4BIT_E         ; Clear E bit
00005Ar 1  8D rr rr       sta VIA_PORTB
00005Dr 1  68             pla
00005Er 1  29 0F          and #%00001111 ; Send low 4 bits
000060r 1  2C rr rr       bit LCD_RS_ENABLE ; enabled RS = $FF
000063r 1  10 02          bpl lcd_instruction_sendlow ;IF RS is NOT enabled THEN skip applying the RS mask
000065r 1  09 10          ora #LCD_4BIT_RS
000067r 1               lcd_instruction_sendlow:
000067r 1  8D rr rr       sta VIA_PORTB
00006Ar 1  09 40          ora #LCD_4BIT_E         ; Set E bit to send instruction
00006Cr 1  8D rr rr       sta VIA_PORTB
00006Fr 1  49 40          eor #LCD_4BIT_E         ; Clear E bit
000071r 1  8D rr rr       sta VIA_PORTB
000074r 1  60             rts
000075r 1               
000075r 1               lcd_print_char:
000075r 1               ;Description
000075r 1               ;  Sends char to the LCD
000075r 1               ;Arguments
000075r 1               ;  A - char to print
000075r 1               ;Preconditions
000075r 1               ;  Char is sent to lcd to get printed
000075r 1               ;Side Effects
000075r 1               ;  Instruction byte is sent to the LCD in 4-bit mode
000075r 1               ;  Register A is squished
000075r 1  48             pha
000076r 1  CE rr rr       dec LCD_RS_ENABLE        ;$00 - 1 = $FF (enabled)
000079r 1  20 rr rr       jsr lcd_instruction
00007Cr 1  9C rr rr       stz LCD_RS_ENABLE        ;$00 (disabled), saves up to three cycles over inc
00007Fr 1  68             pla
000080r 1  60             rts
000081r 1               
000081r 1               lcd_print_hex:
000081r 1               ;Description
000081r 1               ;  Sends hex byte to the LCD
000081r 1               ;Arguments
000081r 1               ;  A - hex to print
000081r 1               ;Preconditions
000081r 1               ;  hex  is sent to lcd to get printed
000081r 1               ;Side Effects
000081r 1               ;  two hex characters are sent to the LCD
000081r 1  DA             phx
000082r 1  48             pha
000083r 1  48             pha
000084r 1  4A             lsr
000085r 1  4A             lsr
000086r 1  4A             lsr
000087r 1  4A             lsr
000088r 1  AA             tax
000089r 1  BD rr rr       lda hexmap, x
00008Cr 1  20 rr rr       jsr lcd_print_char
00008Fr 1  68             pla
000090r 1  29 0F          and #$0F
000092r 1  AA             tax
000093r 1  BD rr rr       lda hexmap, x
000096r 1  20 rr rr       jsr lcd_print_char
000099r 1  68             pla
00009Ar 1  FA             plx
00009Br 1  60             rts
00009Cr 1               
00009Cr 1               lcd_print_asciiz_ZP:
00009Cr 1               ;Description
00009Cr 1               ;  Prints the message to the LCD character by character from the ZP variable
00009Cr 1               ;Arguments
00009Cr 1               ;  A - string
00009Cr 1               ;Preconditions
00009Cr 1               ;  Expected to be called from reset
00009Cr 1               ;  symbol 'asciiz' exists as null terminated string
00009Cr 1               ;Side Effects
00009Cr 1               ;  * a character from asciiz, indexed w/ x
00009Cr 1               ;  * if we find the null at the end of asciiz jump to the nop loop
00009Cr 1               ;  * the character is printed to the lcd
00009Cr 1               ;Note
00009Cr 1  48             pha
00009Dr 1  5A             phy
00009Er 1  A0 00          ldy #0
0000A0r 1               lcd_print_asciiz_print_loop:
0000A0r 1  B1 rr          lda (LCD_PRINT_PTR),y
0000A2r 1  F0 0A          beq lcd_print_asciiz_print_escape
0000A4r 1  20 rr rr       jsr lcd_print_char
0000A7r 1  C8             iny
0000A8r 1  D0 F6          bne lcd_print_asciiz_print_loop
0000AAr 1  E6 rr          inc LCD_PRINT_PTR+1
0000ACr 1  80 F2          bra lcd_print_asciiz_print_loop ; jmp
0000AEr 1               lcd_print_asciiz_print_escape:
0000AEr 1  7A             ply
0000AFr 1  68             pla
0000B0r 1  60             rts
0000B1r 1               
0000B1r 1               hexmap:
0000B1r 1  30 31 32 33    .byte "0123456789ABCDEF"
0000B5r 1  34 35 36 37  
0000B9r 1  38 39 41 42  
0000C1r 1               
