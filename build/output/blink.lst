ca65 V2.18 - Debian 2.19-1
Main file   : source/blink.s
Current file: source/blink.s

000000r 1               ;PURPOSE - This is the code which will written to ROM at $0000 (but will be referenced by the Ben Eater 6502 as $8000)
000000r 1               ;
000000r 1               ;adaptation of https://github.com/dbuchwald/cc65-tools/blob/main/tutorial/03_blink/blink.s by dbuchwald
000000r 1               ;
000000r 1               ;The first difference we'll see is the inclusion of other source files (note they do not have .s extensions, we do not want
000000r 1               ;them assembled as their own objects).
000000r 1               ; ca65 documentaiton: https://cc65.github.io/doc/ca65.html#ss11.66
000000r 1               ;It works like you'd expect an include, the assembler will combine the included files with the source before assembling.
000000r 1               ;
000000r 1               ;Include the via import file (defining the imports there and keeping this source clean)
000000r 1                 .include "via.s_imports"
000000r 2               ;PURPOSE - Imports needed registers defined in via.s
000000r 2               ;
000000r 2               ;Future project - add the rest of the exports from via.s to make them available.
000000r 2               ;blink.s only uses these references so we're only importing those.
000000r 2               ;We could import everything? I'm not smart enough to know if this has a cost on the cc65 (don't think it matters to the generated bin)
000000r 2                 .import VIA_DDRB
000000r 2                 .import VIA_PORTB
000000r 2               
000000r 1                ;
000000r 1                ;BE AWARE THAT LOCATION MATTERS FOR INCLUDED CONTENT, YOU MAY BE BETTER SERVED ADDING YOUR INCLUDED CONTENT ELSEWHERE
000000r 1                ;LIKE AT THE END OF THE CODE.
000000r 1                ;
000000r 1                ;The reset vector will be included at the end of the
000000r 1                ;
000000r 1                ;
000000r 1                ;
000000r 1                ;Aside from the obvious inclusion of the included files, the next big difference we'll see is that
000000r 1                ;the ".org $8000" is gone and replaced with just ".code"
000000r 1                ;
000000r 1                ;This is another thing we get from cc65 https://cc65.github.io/doc/ca65.html#.CODE
000000r 1                ;
000000r 1                ;It is basically a hard coded SEGMENT https://cc65.github.io/doc/ca65.html#.SEGMENT that always gets created for the code.
000000r 1                ;
000000r 1                ;What does the compiler do with all this? Let me take a bit from the generated build\output\output.map
000000r 1                ;file that the compiler creates for us when we do a "make all" (do it yourself on this example to see the full file)
000000r 1               
000000r 1                ;Segment list:
000000r 1                ;-------------
000000r 1                ;Name                   Start     End    Size  Align
000000r 1                ;----------------------------------------------------
000000r 1                ;CODE                  008000  008010  000011  00001
000000r 1                ;VECTORS               00FFFA  00FFFF  000006  00001
000000r 1               
000000r 1                ;We can see that the CODE address space starts at 08000 (and for this program, ends at 008010). But where
000000r 1                ;are we, as the programmer, defining this? The linker configuration files <filename>.cfg
000000r 1                ; reference: https://cc65.github.io/doc/ld65.html
000000r 1                ;
000000r 1                ;MEMORY
000000r 1                ;{
000000r 1                ; VIA:       start=$6000, size=$0010, type=rw, define=yes;
000000r 1                ; ROM:       start=$8000, size=$8000, type=ro, define=yes, fill=yes,   fillval=$00, file=%O;
000000r 1                ;}
000000r 1               
000000r 1                ;SEGMENTS
000000r 1                ;{
000000r 1                ; CODE:      load=ROM,       type=ro,  define=yes;
000000r 1                ; VECTORS:   load=ROM,       type=ro,  define=yes,   offset=$7ffa, optional=yes;
000000r 1                ;}
000000r 1                ;
000000r 1                ;So we can see that CODE is a memory segment, that we tell the linker is read only (cause it is rom). The linker will now try to help us and yell
000000r 1                ;if it thinks we are going to try to write to an address in CODE.
000000r 1                ;
000000r 1                ;CODE says it is loading from the ROM segment. It says define true (yes) so that it could be imported and used as an address in source.
000000r 1                ;
000000r 1                ;The ROM segment has other useful parameters
000000r 1                ;* It is starting at $8000. Remember Ben's 2nd 6502 video? that is where our addressable ROM starts. This is good.
000000r 1                ;* We see that it is $8000 in size, thus we have 16384 addressable bytes or 16KB. Again, this conforms with what Ben said
000000r 1                ;* It says define true (yes) so that it could be imported and used as an address in source.
000000r 1                ;* This is read only space. This makes sense as it is rom. The linker will also try to yell if it thinks we are going to try and write to that ro space
000000r 1                ;* We also define a fill, and a fillvall of $00. So we'll fill the empty space with $00
000000r 1                ;* And "file" parameter without a type looks like it is just asserting (even though this is default) that binary output (.bin) is desired
000000r 1                ;
000000r 1                ;In short, what does this mean? This is a dynamic shorthand for:
000000r 1                ;  .segment CODE
000000r 1                ; or
000000r 1                ;  .org $8000
000000r 1                ;
000000r 1                ; The code segment is special, it gets its own optional segment marker https://cc65.github.io/doc/ca65.html#ss11.13
000000r 1                 .code
000000r 1               
000000r 1               reset:
000000r 1                 ;We want to set all pins on port B of the via adapter to output. Load that state to the accumulator (a)
000000r 1                 ;$ff = %11111111 = 255
000000r 1  A9 FF          lda #$ff
000002r 1                 ;Now we want to write the value in the accumulator (a) to Data Direction Register for via port B (DDRB)
000002r 1                 ;
000002r 1                 ;We have access to the exported values VIA_DDRB & VIA_PORTB because:
000002r 1                 ;* It is imported in the included via.s.inc
000002r 1                 ;* It is exported (and defined) in via.s file
000002r 1                 ;* The via.s file knows what address to use as the starting VIA address because it is defined in firmware.cfg
000002r 1                 ;
000002r 1                 ;See the chain? We can define memory segments in the firmware (with the static values) and have the the code just
000002r 1                 ;reference that instead of storing those constants. This makes the code so much more future proof, if the segments
000002r 1                 ;ever need to move we just update the firmware.cfg
000002r 1  8D rr rr       sta VIA_DDRB
000005r 1               
000005r 1               ;Turn tell the via to set pins 1 and 3 (index started at 0) to true
000005r 1               ;$50 = %01010000 = 80
000005r 1  A9 50          lda #$50
000007r 1  8D rr rr       sta VIA_PORTB
00000Ar 1               
00000Ar 1               loop:
00000Ar 1                 ;rotate the value in the accumulator (a) right
00000Ar 1                 ;so 01010000 will become 00101000
00000Ar 1  6A             ror
00000Br 1                 ;write the rotated accumulator (a) to via port B
00000Br 1  8D rr rr       sta VIA_PORTB
00000Er 1                 ;jump back to the loop reference. We are now looping forever and ever and ever
00000Er 1  4C rr rr       jmp loop
00000Er 1               
